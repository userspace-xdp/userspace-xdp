# simd poc

C code:

```c
#define SIZE 1024

void add_arrays(int *a, int *b, int *result) {
    for (int i = 0; i < SIZE; ++i) {
        result[i] = a[i] + b[i];
    }
}
```

## compile all

```sh
make
```

## native compile result

See loop.c.S, it is the assembly code generated by clang O3 optimization directly.

In the context of your C program and the provided disassembly, SIMD instructions are used to process multiple data points in a single instruction cycle, significantly speeding up operations that are "vectorizable". The disassembly you've posted shows that SIMD instructions are indeed being used:

- `movdqu` instructions are moving data into SSE registers (`%xmm0`, `%xmm1`, `%xmm2`). These instructions handle data in 128-bit chunks, which means they can process multiple single-precision floating-point numbers at once (4 numbers, as each float is 32 bits).
- `paddd` is a SIMD instruction that performs packed addition of 32-bit integers. In this disassembly, it's used to add the contents of two SSE registers, each potentially containing four separate integers, in a single operation.

In the disassembly, the loop at address `0x20` is vectorized using SIMD instructions, processing 16 floats at a time (four per `movdqu` and `paddd` instruction, across four pairs of instructions). After processing these, it increments the pointer (`%rax`) by 16 to move to the next chunk of data. The loop at address `0x90` is a scalar loop that processes the remaining elements one by one in case the array size is not a multiple of 16.

## compile with bpftime

compile bpftime with llvm-jit enabled:

```sh
cmake -B build-bpftime .  -DBUILD_BPFTIME_DAEMON=0 -DBPFTIME_LLVM_JIT=1
make -C  build-bpftime -j
```

compile `loop.bpf.o` with bpftime-vm AOT cli:

```sh
/home/yunwei/ebpf-xdp-dpdk/build-bpftime/bpftime/vm/cli/bpftime-vm build loop.bpf.o
```

it will generate `add_arrays.o`.

disassemble the `add_arrays.o`:

```sh
# objdump -S add_arrays.o 

add_arrays.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <bpf_main>:
   0:   31 c9                   xor    %ecx,%ecx
   2:   66 66 66 66 66 2e 0f    data16 data16 data16 data16 cs nopw 0x0(%rax,%rax,1)
   9:   1f 84 00 00 00 00 00 
  10:   8b 14 0f                mov    (%rdi,%rcx,1),%edx
  13:   8b 04 0e                mov    (%rsi,%rcx,1),%eax
  16:   48 01 d0                add    %rdx,%rax
  19:   89 04 11                mov    %eax,(%rcx,%rdx,1)
  1c:   48 83 c1 04             add    $0x4,%rcx
  20:   48 81 f9 00 10 00 00    cmp    $0x1000,%rcx
  27:   75 e7                   jne    10 <bpf_main+0x10>
  29:   c3                      ret
```

Seems the compiler didn't generate SIMD instructions directly in this approach.

Analysis:

```console
root@yunwei-server:/home/yunwei/ebpf-xdp-dpdk/documents/simd-poc# clang -O3 -mavx
 -Rpass-analysis=loop-vectorize  -c bpf-jit-opt.ll
remark: <unknown>:0:0: loop not vectorized: cannot identify array bounds [-Rpass-analysis=loop-vectorize]
```

## can be vectorized in clang C but not in eBPF case 1: loop

```c
struct xdp_md
{
	void* data;
	void* data_end;
};


int add_arrays(struct xdp_md *ctx) {
    char *data_end = ctx->data_end;
	char *data = ctx->data;
    int size = data_end - data;
    // test vectorization
    for (int i = 0; i < size; i++) {
        data[i] = data[i] + 1;
    }
    return 0;
}
```

will result in:

```console
$ clang -O3 -mavx -Rpass-analysis=loop-vectorize  -c  loop.bpf.ll
remark: <unknown>:0:0: loop not vectorized: unsafe dependent memory operations in loop. Use #pragma loop distribute(enable) to allow loop distribution to attempt to isolate the offending operations into a separate loop
Unknown data dependence. [-Rpass-analysis=loop-vectorize]
```


## can be vectorized in clang C but not in eBPF case 2: loop1

```c
struct xdp_md
{
	void* data;
	void* data_end;
};

#define BUFFER_SIZE 64

int add_arrays(struct xdp_md *ctx) {
    char *data_end = ctx->data_end;
	char *data = ctx->data;
    char buffer[BUFFER_SIZE];
    int size = data_end - data;
    if (size < BUFFER_SIZE) {
        return -1;
    }
    // test vectorization
    for (int i = 0; i < BUFFER_SIZE; i++) {
        buffer[i] = data[i] + 1;
    }
    for (int i = 0; i < BUFFER_SIZE; i++) {
        data[i] = buffer[i];
    }
    return 0;
}

```

will result in:

```console
$ clang -O3 -mavx -Rpass-analysis=loop-vectorize  -c  loop1.bpf.ll
remark: <unknown>:0:0: loop not vectorized: value that could not be identified as reduction is used outside the loop [-Rpass-analysis=loop-vectorize]
remark: <unknown>:0:0: loop not vectorized: could not determine number of loop iterations [-Rpass-analysis=loop-vectorize]
yunwei@octopus1:~/ebpf-xdp-dpdk/documents/simd-poc$ 
```

```c

## error on clang

```c
#define SIZE 1024

void add_arrays(float *a, float *b, float *result) {
    for (int i = 0; i < SIZE; ++i) {
        result[i] = a[i] + b[i];
    }
}

```

will result in the following error:

```console
root@yunwei-server:/home/yunwei/ebpf-xdp-dpdk/documents/simd-poc# make
clang -O3 -target bpf -c loop.bpf.c -o loop.bpf.o
loop.bpf.c:3:6: error: A call to built-in function '__addsf3' is not supported.
void add_arrays(float *a, float *b, float *result) {
     ^
1 error generated.
make: *** [Makefile:4: loop.bpf.o] Error 1
root@yunwei-server:/home/yunwei/ebpf-xdp-dpdk/documents/simd-poc# make
clang -O3 -target bpf -c loop.bpf.c -o loop.bpf.o
clang -O3 -c loop.bpf.c -o loop.o
```
